#Output results to a log file as well as to the screen
sink("PIC_results_log.txt",append=FALSE,split=TRUE)
print("Usage: asr_viz_phytools.r <treefile> <trait_table>")
args <- commandArgs(trailingOnly=TRUE)
treefile <- args[1]
trait_table <-args[2]

library(phytools)

#Plotting parameters
red_colorscheme <- c('white','yellow','orange','red','black')
purple_colorscheme <-c('white','pink','purple','black')
green_colorscheme <-c('white','yellow','springgreen3','black')
inverse_green_colorscheme <-c('black','springgreen3','yellow','white')
inverse_red_colorscheme <-c('black','red','orange','yellow','white')
#inverse_purple_colorscheme <-c('black','purple','pink','white')

metrics <-c('equitability','observed_otus','PD_whole_tree')
y_metrics <-c('oz_disease_mean')
tree_direction <-"leftwards"
print(paste(metrics,sep=","))

for (metric in metrics){
for (y_metric in y_metrics){
    print(paste("Analyzing",metric,"vs.",y_metric))

    tab <- read.table(trait_table,comment.char="",header=T,row.names=1)
    tre <- read.tree(treefile)

    #Filter table to tree tips
    newtab <- tab[rownames(tab) %in% tre$tip.label,]
    #Drop NA rows for our metric
    newtab <- newtab[!is.na(newtab[,metric]),]

    #Restrict to just our column of interest
    newtab2 <- newtab[,metric]
    names(newtab2) <- rownames(newtab)


    #Filter tree to table
    tre2 <- drop.tip(tre,tre$tip.label[!tre$tip.label %in% names(newtab2)])

    fit<-fastAnc(tre2,newtab2,vars=TRUE,CI=TRUE)

    #Print model fit to screen
    print(paste(c("FastAnc ML modelfit for",metric)))
    print(fit)
    obj <- contMap(tre2,newtab2,plot=F)
    obj <- setMap(obj,colors=inverse_green_colorscheme)
    #Regress vs. oz_disease_mean

    #Writing to file
    pdf(paste("asr_contmap_",metric,".pdf",sep=""))
    par(mai=c(12.12,1,1.1,1.1))
    plot(obj,direction=tree_direction,legend=0.7*max(nodeHeights(tre2)),fsize=c(0.222,0.9))
    nodelabels(bg="white",frame='none',adj=c(1.1,0.4),cex=0.9)
    axis(1)
    title(xlab="time from the root (mya)")
    dev.off()

    pdf(paste("asr_phenogram_",metric,".pdf",sep=""))
    phenogram(tre2,newtab2,spread.cost=c(1,0))
    axis(1)
    title(xlab="time from the root (mya)")
    dev.off()



    #Get our y-value column of interest
    newtabY <- newtab[,y_metric]
    names(newtabY) <- rownames(newtab)

    X <- newtab2
    #print("X:")
    #print(X)

    Y <- newtabY
    #print("Y:")
    #print(Y)


    print(paste("Fitting raw linear regression before PIC for",metric,"(x) vs. ",y_metric,"(y)"))
    raw_fitXY <-lm(X ~ Y )
    raw_fitYX <-lm(Y ~ X )
    print(summary(raw_fitXY))

    #Dichotemize tre2
    trait1 <- metric
    trait2 <- y_metric
    tre2 <- multi2di(tre2)
    #tre2 <- midpoint.root(tre2)


    #print("Calculating PIC")
    #****POSITIVIZE PIC VALUES (negative signs are arbitrary)
    #NOTE: this is not just the absolute value since the difference x=-1 y=2
    #has a different interpretation than x=1 y=2

    #Code snippet from:https://github.com/bomeara/ComparativeMethodsInR/blob/master/ContinuousTrait_Answers.R
    #for contrasts, you should positivize them, since the order doesn't matter. This is NOT taking absolute value.
    PositivizeContrasts <- function(x, y) {
	      x.positivized <- x * sign(x)
	      y.positivized <- y * sign(x)
	      return(cbind(x.positivized, y.positivized))
    }

    positivized.results <- PositivizeContrasts(pic.X, pic.Y)
    pic.X <-positivized.results[,1]
    pic.Y <-positivized.results[,2]
    

    #Try to plot PIC omitting zero y-values (generated by species --> sample mappings)
    epsilonX = 0.05 * min(X)
    epsilonY = 0.05 * min(Y)
    Y_nonzero_indices = which(abs(0-pic.Y) > epsilonY)
    pic.X.nonzeroY = pic.X[Y_nonzero_indices]
    pic.Y.nonzeroY = pic.Y[Y_nonzero_indices]
    X_nonzero_indices = which(abs(0-pic.X.nonzeroY) > epsilonX)
    pic.X.nonzero = pic.X.nonzeroY[X_nonzero_indices]
    pic.Y.nonzero = pic.Y.nonzeroY[X_nonzero_indices]



    for (method in c('spearman','pearson')){
        corXY <- cor.test(pic.X, pic.Y,method=method)
        print(paste("Correlation test for PICs of",metric,"(x) vs. ",y_metric,"(y)"))

        print(paste("Summary cor.test for PICs ",method))
        print(corXY)
    }
    fitYX <- lm(pic.Y ~ pic.X - 1 ) # regress through origin
    print(paste("Summary lm pic.Y ~ pic.X -1 INCLUDING zero change PICs for" ,metric,"(x) vs. ",y_metric,"(y)"))
    print(summary(fitYX))

    fitYX.nonzero <- lm(pic.Y.nonzero ~  pic.X.nonzero - 1 ) # both regressions
    print(paste("Summary lm pic.Y ~ pic.X -1 non-zero PICs only for" ,metric,"(x) vs. ",y_metric,"(y)"))
    print(summary(fitYX.nonzero))


    ## this is a projection of the tree into morphospace
    ##This code snippit is adapted from a phytools tutorial (http://www.phytools.org/Cordoba2017/ex/3/PICs.html)
    pdf(paste(trait1,"_",trait2,"_phylomorphospace.pdf",sep=""))
    phylomorphospace(tre2,cbind(X,Y),xlab=trait1,ylab=trait2,label="off",node.size=c(0,0))
    points(X,Y,pch=21,bg="grey",cex=1.4)
    abline(fitYX,lwd=2,col="red")

    #Save as a pdf
    pdf(paste(trait1,"_",trait2,"_pic_scatter_YX.pdf",sep=""))
    plot(pic.X,pic.Y,xlab=trait1,ylab=trait2,color='gray',pch=16)
    abline(fitYX,col="red")
    dev.off()

    #Save as a pdf
    pdf(paste(trait1,"_",trait2,"_pic_scatter_YX_nonzero_PICS_only.pdf",sep=""))
    plot(pic.X.nonzero,pic.Y.nonzero,xlab=trait1,ylab=trait2,color='gray',pch=16)
    abline(fitYX.nonzero,col="red")
    dev.off()


    #Save raw data as pdf
    pdf(paste(trait1,"_",trait2,"_raw_scatter.pdf",sep=""))
    plot(X,Y,xlab=trait1,ylab=trait2,color='gray', pch=16)
    abline(raw_fitYX,col="red")
    dev.off()


}
}
